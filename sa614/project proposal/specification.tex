\documentclass[]{report}


% Title Page
\title{Functional Specification - Race The Wild}
\author{Team Foxtrot}


\begin{document}
\maketitle

The group has been tasked with using animal tracking data, as well as tracking via smartphone to produce an application that educates about animals. The following brief is an idea that aims to blend these with a product people will find appealing to use. The project arises out of a desire to improve public engagement with wildlife, in a way which promotes understanding, knowledge and imagination, via a smartphone application.

It is clear, therefore, that satellite tracking is a key aspect of the project. The group must therefore design modules to collect information based on the player's movements. What is less clear is how to use this information in a product. The method the group has chosen is using the player's movements as a point of comparison to a database of animals, and then using this information to allow the character to progress inside a virtual world as part of the application.  To allow them to move inside this virtual world, by ``checking in'' users will receive movement points based on how far they have travelled, which will allow them to move between various habitats to find animals. The goal of this is not for people to drive around to receive points; the method we have chosen to avoid this is to track movement velocities and reward more points for behaviour which appears to be walking or cycling. Another possible use of this data would be to use animal data to compare with a real person's athletic ability, by having the person ``race'' the animal. The idea would be that we used a combination of real and modelled tracking data to encourage the end user to perform more exercise each day via movement than the given animal. However, this idea was deemed to be suitable only for a very specific target market that wouldn't necessarily be the same target market that would be interested in the educational side of the application.

The idea is that the world map will be presented as a simple touch based graph interface, with costs for moving between nodes. The end user, once an animal is available to find, will have to guess / work out which habitat the animal is most suited to (perhaps via research), with hints available, and then can move to the correct location to find it.

Once in a location, the user can scroll around it using a touch interface, in an attempt to find any animals they have been compared to but have not yet found. Animals which have already been found will also be in the area, to give the game a slight difficulty curve, and by touching the new animal once found, it can be added to the collection. As a reward for finding an animal, the user will be presented with various facts about it, as well as the thrill of having collected something.

To see their progress, or find information on animals they have encountered via walking but are yet to find in the game, the user can visit the collection screen. This will give them access to this information, as well as the facts they have collected about each animal. This will also be navigable by a scrolling touch interface.

Possible extensions to the project are a separate application to add new animals to the program via a simple PC graphical user interface, and perhaps a mission based system to, for example, find food for animals in the user's collection, to educate on the diets of animals. The project is also ripe for extension based on other data we may receive, provided it can integrate well with the rest of the design.

It is clear that the target audience would therefore be late primary / secondary school children, as that is the audience most likely to be interested in such a fact collecting game, though it is intended that the game have as wide an appeal as possible; indeed it is likely that University level students could also be interested in using the application.

As the project should be written in Java, the natural platform of choice is Android. Though this sacrifices the ability to have it run on as many platforms as possible (ruling out Windows Phone 7 and iOS), it does allow speedy development and also allows us to use some of the advanced features Android permits, such as OpenGL. We have decided to target Android 2.2 onwards, in line with Google's recommendations, and also to support over 90\% of the Android smartphones in active use\footnote{Sourced from http://developer.android.com/about/dashboards/index.html on 28/01/2013}.

In summary, the main components of the system are the satellite tracker, the user interface, the core engine, the check-in system, the animal collection, the scrolling map system, and the node-based world map.

The satellite tracker needs to run as a background process on the system, as the user will want to track their movements even when the application is not their focus. This means the tracker needs to have a separate lifecycle, communicating with the main process using Android's IPC feature. We note, however, that satellite navigation is very battery consuming; this means we need to give the user an easy method of turning the feature off when they don't wish to be tracked. It also means we shouldn't continuously track the user; a sufficient sleeping time for the feature, perhaps 5 minutes, should be used to balance accuracy of tracking for the realities of finite battery life. It is proposed that this will be split up into three layers: a raw data layer, which directly interfaces with the satellite navigation layer, passing up to the next layer when movement has been confirmed (outside of an error range) a set of coordinate time tuples. This will allow the second layer to perform calculations based on both distance and average speed of movement between points, and these details can then be passed to the following layer, which can use these to calculate ``movement points'' based on distance and speed, and accumulate distance travelled. On request, this final layer can then parcel the data into a \textit{(Distance,Movement Points)} pair to send to the main application using the Parcelable interface and Android's IPC (inter-process communication) feature.

The core engine will control core platform independent functionality of the system, with references to all other parts of the system. Communication between different parts of the system will be handled here, and the plan is that a reference to the engine will be held by most other parts of the system. This will allow an interface to be assumed for each other part to communicate without any detailed knowledge of each component, and is itself a component that won't require deep technical knowledge of Android.

The user interface needs to be designed using Android's activity system for different scenes. This can be split up into separate activities for the collection, the check-in screen, the menu screen, the scrolling map system and the node-based world map. The menu screen is the simplest of these. This will be a collection of three navigation buttons to the world map, check-in and collection. It is suggested that a preview of check-in data may also be presented here depending on the latency properties of IPC between processes on Android. The check-in screen will require pictures, text and buttons to accommodate its functionality, as well as a call to Engine to get movement information. The animal collection can be implemented using a scrolling list of animal objects, with actions when one of these is selected. This all requires very platform specific knowledge of Android, so should be implemented by someone with that capability.

The scrolling map system and the node-based world map are more complicated. It is likely that these will be implemented using drawing calls provided by OpenGL ES 2.0, the embedded systems graphics library available for Android. These systems will also require buttons and text boxes provided by Android's Activity system, so can be counted as a specific instance of the user interface system. Both of these will require knowledge, therefore, of OpenGL. These systems both also require an extensive amount of image assets to be functional; in an ideal system there would be a great many of these for the project, but since we have a limited amount of time and intend this to be a technical rather than art project, it is likely that we will provide a subset of assets for a potential full release version, with the capability of easy expansion should new assets become available.

The scrolling map will be based on one large image background (larger than the screen itself) per environment. It is noted that the file size of this in memory will be fairly large; it may be decided to load this in parts depending on which area of the screen is shown at the time. The other option would be to create tile based maps, but this is likely to require extensive knowledge of the OpenGL API, and require a lot of time commitment, though would potentially allow for smaller assets. On this, animals already collected in that habitat will be laid out randomly across the screen, with the intent to fill it relatively densely. Animals found by the check-in system but not yet in the virtual world will be placed in the habitats they should exist in, but only one of each type will exist at any one point in each compatible habitat. Touching one of these new animals will trigger a call to add the animal to the collection, as well as move the player to the collection interface to receive facts. Multiple different environments must be created like this, to allow the player to move between them.

The node based map will allow players to move between the above environments by spending their ``movement points''. This means a touchable graph should be constructed with links between different environments with associated costs to move between each node. Ideally a realtime implementation of Djikstra could be used to give costs, but since we have limited time a stored, imprecise cost between each node is instead likely to be used, as this probably won't affect the end user. This system is also likely to need extensive OpenGL calls, as it's a fairly heavyweight system for the stock Activity interface.

The animal collection, as well as the interface described above, needs to have a dictionary of content. It is proposed that we store this as a Java Map of $<$Integer,Animal$>$ that can be loaded at runtime; the reason being for this is that potentially information could be added to this via a separate application designed to record animals, which could then be added into the game automatically. This means definition of an Animal class is needed. This should store basic data such as location in game world, movement data, and a string of a sprite location, but not the full sprite: as we keep the whole dictionary in memory at all times it is wasteful to store every sprite we have all the time, and we would quickly run out of memory. 

Of course, if the user is to make progression using this system, we will need to store save data on the Android storage. This will consist of variable storage for current movement points, total movement points, total distance travelled, the node they are currently in (ie which scrolling map they are inside, to allow for proper costing between nodes), a list to store found animals, and a list of animals found via walking but not in the in-game world. These may be changed to maps depending on the best implementation of the methods using this data. This can then be loaded back in at runtime, and saved when any changes to these states are made. We will also have to save the data tracked by the sat-nav process in the event of it being forcefully closed by the user or the system. This can be achieved by saving the required information when closing, and reloading if this has been the case when the process is restarted.

In terms of acceptance criteria, the product needs to be stable on release. This means there should be no path through the program which causes the application to hang in any way. We also need to take steps to avoid loss of data or corruption as a result of the program, meaning when data is saved it should not be able to corrupt existing data without being consistent itself. The finished product should have a fully functioning satellite navigation tracker in place that records distance information, though it does not need to be accurate to within a reasonable error. It is deemed that the performance of the tracker will be acceptable provided it does not generate false movement data when the device is stationary. 

The application should not be allowed to stall for a length of time that would cause Android to kill the process. This means, in practice, that our interface must not stall for longer than twenty seconds. In general even this experience would be unsatisfactory for an end user; however the practicalities of Android development mean setting this bar lower may be optimistic without taking measure of our final implementation.

We should, by the end of the project, have provided a working implementation of the animal collection list, the node world map system, and the scrolling map interface. It is deemed that without these the product would be useless, and therefore not worth releasing. It is not deemed, however, that all content should be in place. A proof of concept, with enough assets to show all the necessary features of the application, is enough, as the project is not about asset creation and is instead a technical one. The product also needs to be aesthetically functional though it does not need to be attractive; again, a proof of concept is all that is necessary.

The project will be managed by Ciaran Deasy. [SOME OTHER STUFF NEEDS TO GO HERE TOO]









\end{document}          
