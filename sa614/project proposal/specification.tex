\documentclass[]{report}


% Title Page
\title{Functional Specification - Race The Wild}
\author{Team Foxtrot}


\begin{document}
\maketitle

\section*{1. Overview}

For this IB Group Project, the assigned task is to use animal tracking data, as well as location tracking via smartphone to produce an application that educates users about animals. The following brief is an idea that aims to turn this concept into a product people will find appealing to use. The project arises out of a desire to improve public engagement with wildlife, in a way which promotes understanding, knowledge and imagination, via a smartphone application.

\section*{2. Concept}

It is clear that satellite tracking is a key aspect of the project. The group must therefore design modules to collect information based on the player's movements. What is less clear is how to use this information in a product. The approach the group has chosen is to compare the player's movements to a database of historic animal tracking data. Based on similarity of distance travelled, new animals are released into a virtual world inside the application for the user to collect. 

To allow them to move around between various habitats to find animals, users will also receive movement points from their check-in based on how far they have travelled. A possible exploit of this would be for people to drive around to receive points more easily; the method chosen to avoid this is to track movement velocities and reward more points for behaviour which appears to be walking or cycling. 

Another possible approach that the group considered was to use animal data to compare with a real person's athletic ability, by having the person ``race'' the animal. The idea would be that we used a combination of real and modelled tracking data to encourage the end user to achieve more movement than a given animal each day, thereby promoting exercise. However, this idea was deemed to be suitable only for a very specific target market that wouldn't necessarily include people that would be interested in the educational side of the application.

The world map will be presented as a simple touch-based graph interface, with users paying movement points to travel between nodes. Once an animal is available to find, the user will have to guess / work out which habitat the animal is most suited to (perhaps via research), and can then move to the correct location to find it.

Once in a location, the user will be presented with a 2D environment. Using a touch interface, they can scroll around in an attempt to find any animals that have been released but not yet found. Animals which have already been found will also be in the area, to give the game a slight difficulty curve, and to give a sense of progression as the user's collection grows. Once the animal has been found, it can be touched to add it to the collection. As a reward for finding an animal, the user will be presented with some interesting facts about it.

To see their progress, or find information on animals that have been released but not found, the user can visit the collection screen. This will give them access to hints about unfound animals, as well as the facts about each animal they have collected already. This will be navigable by a scrolling touch interface.

Possible extensions to the project are a separate application to add new animals to the program via a simple PC graphical user interface, or a mission based system to, for example, find food for animals in the user's collection, to educate on the diets of animals. The project is also ripe for extension based on other data we may receive, provided it can integrate well with the rest of the design.

It is clear that the target audience would be late primary / secondary school children, as that is the audience most likely to be interested in such a collecting-focused game. However it is intended that the game would have as wide an appeal as possible; indeed it is likely that University level students could also be interested in using the application.

As the project should be written in Java, the natural platform of choice is Android. Though this sacrifices the ability to have it run on as many platforms as possible (ruling out Windows Phone 7 and iOS), it does allow speedy development and also allows us to use some of the advanced features Android permits, such as OpenGL. We have decided to target Android 2.2 onwards, in line with Google's recommendations, and also to support over 90\% of the Android smartphones in active use\footnote{Sourced from http://developer.android.com/about/dashboards/index.html on 28/01/2013}.

\section*{3. Technical Specifications}

In summary, the main components of the system are:
\begin{itemize}
\item the core engine
\item the satellite tracker
\item the user interface
\item the check-in system
\item the node-based world map
\item the scrolling map system
\item the animal collection
\end{itemize}

\subsection*{3.1. Core Engine}

The engine will control core, platform-independent functionality of the system, with references to all other parts of the system. a reference to the engine will be held by most other parts of the system, and communication between different parts of the system will be done via this object. This will provide a central interface, insulating components from each other. The engine itself won't require deep technical knowledge of Android.

\subsection*{3.2. Satellite Tracker}

The satellite tracker needs to run as a background process on the system, as the user will want to track their movements even when the application is not their focus. This means that the tracker needs to have a separate lifecycle, communicating with the main process using Android's IPC (Inter-Process Communication) feature. We note, however, that satellite navigation is very battery-intensive; this means we need to give the user an easy method of turning the feature off when they don't wish to be tracked, such as a button in the application's main menu. It also means we shouldn't continuously track the user; a sufficient sleeping time for the feature, perhaps 5 minutes, should be used to balance accuracy of tracking with the realities of finite battery life. 

It is proposed that the component will be split up into three layers. At the bottom will be a raw data layer, which directly interfaces with the satellite navigation system, exporting a (coordinate, time) tuple when movement has been confirmed (outside of an error range). The second layer will perform calculations of distance and average speed of movement between points, which can then be exported to the following layer. The top layer will use these calculations to determine the ``movement points'' and travel distance to give the player. 

All of this will be repeated at regular intervals (probably five minutes) and the results accumulated. On request from the main application, this data can then be parcelled into a \textit{(Distance, Movement Points)} pair and sent using the Parcelable interface and Android's IPC (inter-process communication) feature.

\subsection*{3.3 User Interface}

The user interface needs to be designed using Android's activity system for different scenes. This can be split up into separate activities for the collection, the check-in screen, the menu screen, the scrolling map system and the node-based world map. The menu screen is the simplest of these. This will be a collection of three navigation buttons to the world map, check-in and collection. It is suggested that a preview of the value of checking-in may also be presented here, subject to the latency properties of IPC between processes on Android. The check-in screen will require pictures, text and buttons to accommodate its functionality, as well as a call to Engine to get movement information. The animal collection can be implemented using a scrolling list of animal objects, with actions when one of these is selected. This all requires very platform specific knowledge of Android, so should be implemented by someone with that capability.

\subsection*{3.4. Node Map}

The scrolling map system and the node-based world map are more complicated. It is likely that these will be implemented using drawing calls provided by OpenGL ES 2.0, the embedded systems graphics library available for Android. These systems will also require buttons and text boxes provided by Android's Activity system, so can be counted as a specific instance of the user interface system. Both of these will require knowledge, therefore, of OpenGL. These systems both also require an extensive amount of image assets to be functional; in an ideal system there would be a great many of these for the project, but since we have a limited amount of time and intend this to be a technical rather than art project, it is likely that we will provide a subset of assets for a potential full release version, with the capability of easy expansion should new assets become available.

The node based map will allow players to move between the above environments by spending their ``movement points''. This means a touchable graph should be constructed with links between different environments with associated costs to move between each node. Ideally a realtime implementation of Djikstra could be used to give costs, but since we have limited time a stored, imprecise cost between each node is instead likely to be used, as this probably won't affect the end user. This system is also likely to need extensive OpenGL calls, as it's a fairly heavyweight system for the stock Activity interface.

\subsection*{3.5. Scrolling Map}

The scrolling map will be based on one large image background (larger than the screen itself) per environment. It is noted that the file size of this in memory will be fairly large; it may be decided to load this in parts depending on which area of the screen is shown at the time. The other option would be to create tile based maps, but this is likely to require extensive knowledge of the OpenGL API, and require a lot of time commitment, though would potentially allow for smaller assets. On this, animals already collected in that habitat will be laid out randomly across the screen, with the intent to fill it relatively densely. Animals found by the check-in system but not yet in the virtual world will be placed in the habitats they should exist in, but only one of each type will exist at any one point in each compatible habitat. Touching one of these new animals will trigger a call to add the animal to the collection, as well as move the player to the collection interface to receive facts. Multiple different environments must be created like this, to allow the player to move between them.

\subsection*{3.6. Animal Collection}

The animal collection, as well as the interface described above, needs to have a dictionary of content. It is proposed that we store this as a Java Map of \verb|<Integer,Animal>| that can be loaded at runtime; the reason being for this is that potentially information could be added to this via a separate application designed to record animals, which could then be added into the game automatically. This means definition of an Animal class is needed. This should store basic data such as location in game world, movement data, and a string of a sprite location, but not the full sprite: as we keep the whole dictionary in memory at all times it is wasteful to store every sprite we have all the time, and we would quickly run out of memory. 

Of course, if the user is to make progression using this system, we will need to store save data on the Android storage. This will consist of variable storage for current movement points, total movement points, total distance travelled, the node they are currently in (ie which scrolling map they are inside, to allow for proper costing between nodes), a list to store found animals, and a list of animals found via walking but not in the in-game world. These may be changed to maps depending on the best implementation of the methods using this data. This can then be loaded back in at runtime, and saved when any changes to these states are made. We will also have to save the data tracked by the sat-nav process in the event of it being forcefully closed by the user or the system. This can be achieved by saving the required information when closing, and reloading if this has been the case when the process is restarted.

\section*{4. Project Setup}

In terms of acceptance criteria, the product needs to be stable on release. This means there should be no path through the program which causes the application to hang in any way. We also need to take steps to avoid loss of data or corruption as a result of the program, meaning when data is saved it should not be able to corrupt existing data without being consistent itself. The finished product should have a fully functioning satellite navigation tracker in place that records distance information, though it does not need to be accurate to within a reasonable error. It is deemed that the performance of the tracker will be acceptable provided it does not generate false movement data when the device is stationary. 

The application should not be allowed to stall for a length of time that would cause Android to kill the process. This means, in practice, that our interface must not stall for longer than twenty seconds. In general even this experience would be unsatisfactory for an end user; however the practicalities of Android development mean setting this bar lower may be optimistic without taking measure of our final implementation.

We should, by the end of the project, have provided a working implementation of the animal collection list, the node world map system, and the scrolling map interface. It is deemed that without these the product would be useless, and therefore not worth releasing. It is not deemed, however, that all content should be in place. A proof of concept, with enough assets to show all the necessary features of the application, is enough, as the project is not about asset creation and is instead a technical one. The product also needs to be aesthetically functional though it does not need to be attractive; again, a proof of concept is all that is necessary.

The project will be managed by Ciaran Deasy. [SOME OTHER STUFF NEEDS TO GO HERE TOO]

[DISCUSS THE ITERATIVE DEVELOPMENT MODEL]







\end{document}          
